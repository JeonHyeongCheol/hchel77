package pack3;

public final class Me extends Father{
	
	private int nai = 20;
	public final String irum = "유일해";   //값 수정 불가
	// final - 마지막의, 변경될 수 없는
	// final 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
	// 클래스 - 변경될 수 없는 클래스, 확장 될 수 없는 클래스
	// 메서드 - 변경될 수 없는 메서드, final로 지정된 메서드는 오버라이딩을 통해 재정의 될 수 없음.
	// 멤버변수, 지역 변수 - 변수 앞에 final이 붙으면, 값을 변경할 수 없는 상수가 됨.
	
	// final 멤버 변수의 초기화 할 수 있는 방법 : 
	// 상수지만 선언과 함께 초기화하지 않고 생성장에서 단 한번 초기화 할 수 있음.
	
	// 제어자 : 클래스, 변수 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여
	// 접근 제어자 : public, protected default, private
	// 그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
	
	// Static - 클래스의, 공통적인
	// static이 붙은 멤버변수, 메서드, 초기화 블럭은 인스턴스가 아닌 클래스에 관계되어있기 때문에 인스턴스를 생성하지 않고 사용 가능
	// 인스턴스 메서드와 static메서드의 근본적인 차이는 메서드 내에서 인스턴스 멤버를 사용하는가의 여부
	// static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
	// 멤버 변수 : 모든 인스턴스에 공통적으로 사용되는 클래스 변수, 인스턴스를 생성하지 않고 사용 가능, 클래스가 메모리 로드될 때 생성
	// 메서드 : 인스턴스를 생성하지 않고도 호출이 가능한 static메서드가 됨, static메서드 내에서는 인스턴스 멤버들을 직접 사용 할 수 없음.
	public String data = "Me data";                    //지역 데이터가 우선순위다.
	
	public Me() {
		super(20);
		System.out.println("내 생성자");
	}
	
	public /*final*/ void play() {                       //me에만 가지고있는 고유의 메소드   여기서의 final은 의미가 없다 더 불러올 사람이 없기때문.
		System.out.println("하고 싶은 거 하기");
	}
	
	@Override
	public int getNai() {
		return nai;
	}
	
//	public final void eat() {
//		System.out.println("밥은 맛있게...");
//	}

	public void displayDate() {
		String data = "displayDate method의 data";                   //우선순위의 데이터를 찾아간다  (클레스 맴버의 데이터)
		System.out.println(data);
		System.out.println(this.data);
		System.out.println(super.data);                         //부모의 데이터를 볼려면 super을 써야함.
		
	}
}