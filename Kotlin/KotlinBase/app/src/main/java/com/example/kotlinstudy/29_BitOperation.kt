package com.example.kotlinstudy

class `29_BitOperation` {
    // Title : 비트연산

    // 비트연산
    // 정수형 변수를 사람이 사용하는 10진법으로 연산하는 대신
    // 2진법인 비트 단위로 연산 할 수 있는 방법

    // 실무에서 비트연산은 거의 계산에는 사용하지 않음
    // 참고 : 2진법을 이용한 연산 최적화가 필요하다면 컴파일러 기능을 사용하는 경우가 대부분
    // 정수형의 값을 비트단위로 나누어 데이터를 좀 더 작은 단위로 담아
    // 경제성을 높이기 위한 용도로 사용 됨

    // 예를 들어
    // 32비트를 통으로 쓰는게 아닌 Integer 타입의 0 과 1로 된 서로 다른 값을 넣거나
    // 앞의 5비트와 뒤의 27비트를 따로 서로 다른 값을 넣어 사용 할 수 있음

    // 변수 하나에 여러개의 값을 담아 사용 할 수 있음
    // 다만 비트 연산을 사용하는 부하도 무시 할 수 없으므로
    // 주로 플래그 값을 처리하거나(여러개의 상태값을 0 과 1로 담는 방법)
    // 네트워크 등에서 프로토콜의 데이터 양을 줄이기 위해 자주 사용 됨

    // 00101010101010101010101010101010101010101011
    // 상위비트                                 하위비트
    // 좌측으로 갈 수록 상위비트 우측으로 갈수록 하위비트가 됨

    // 참고로 코틀린은 모든 정수형이 부호를 포함하므로(참고 : 부호없는 정수형도 실험 중에 있음)
    // 최상위 비트는 0이면 양수, 1이면 음수인 부호비트로 사용
    // 이 부분에는 데이터를 담지 않는 것이 좋음


    // 비트를 밀어주는
    // bitwise shift operators

    // 부호비트(첫번째를) 제외한 모든 비트를 좌측으로 밀어주는 기능
    // shl(shift left)

    // 부호비트를(첫번째를) 제외한 모든 비트를 우측으로 밀어주는 기능
    // shr(shift right)

    // 부호비트를 포함하여 모든 비트를 우측으로 밀어주는 기능
    // ushr(unsigned shift right)


    // 비트를 조작하는
    // bitwise operators

    // and
    // 비트가 둘다 1인 자리만 1로 반환
    // 1010 and 0110
    // 결과값 0010

    // or
    // 비트가 둘 중 하나라도 1인 자리는 1로 반환
    // 1010 or 0110
    // 결과갑 1110

    // xor
    // 비트가 같은 자리는 0, 다른 자리는 1로 반환
    // 1010 xor 0110
    // 결과값 1100

    // and 연산자는 그 특성을 이용하여 두 가지 기능으로 사용

    // 비트를 확인하는 방법
    // 원본  0 1 1 0
    // 비교값 0 1 0 0
    // 아래서 세번째 비트의 값만 알고 싶은 경우에는?
    // 1을 넣어 and 연산자 사용한 결과값 0 1 0 0

    // 비트를 clear 하는 방법
    // 원본  0 1 1 0
    // 비교값 1 1 0 0
    // 아래 두 개의 비트를 0으로 만들고 싶은 경우에는?
    // 0을 넣어 and 연산자 사용한 결과값 0 1 0 0

    // or 연사는 반대로 비트의 set 연산, 즉
    // 비트 값을 1로 설정하고 싶을 때 사용
    // 비트를 set 하는 방법
    // 원본  0 1 1 0
    // 비교값 1 1 0 0
    // 상위 두 개의 비트를 1로 만들고 싶은 경우에는?
    // 1을 만들고 싶은 곳에만 1을 넣어 or 연산자 사용한 결과값 1 1 0 0

    // xor 연산자
    // 비트들이 같은지 비교하는 방법
    // 원본  0 1 1 0
    // 비교값 1 1 0 0
    // 내가 원하는 값과 비트들이 똑같은지?
    // 결과값 1 0 1 0


    // 비트를 반전하는
    // inv()
    // 비트를 모두 반전시키는 역할
    // 0 -> 1 , 1 -> 0

    fun main() {

        // 0b1000 (하위) 다섯번쨰 비트에 1넣으면?
        var bitData: Int = 0b10000 // 지정되지 않는 상위 비트들은 0으로 채워짐

        // 여기서 (하위) 세 번째 비트에 1을 set 하면?
        // 1 이라는 값을 shl 을 사용하여 좌측으로 2번 밀어버림(0b100)
        // 그리고 이 값을 bitData 와 or 연산하면
        // (하위) 세 번째 비트가 set 되게
        bitData = bitData or (1 shl 2) // 0b10000 or 0b100 > 결과값 0b10100

        // 정수형의 경우 toString 의 패러미터를 진법 변환 할 수 있음
        // 2진수 형태의 문자열로 변경하여 출력
        println(bitData.toString(2)) // 10100

        // and 연산을 통해 (하위) 다섯번째 비트에 있는 값을 꺼내려면?
        // 1 이라는 값을 shl 을 사용하여 좌측으로 4번 밀어버림(0b10000)
        // 이 값을 bitData 와 and 연산하면
        // (하위) 다섯번째 비트의 값을 제외한 나머지는 0이 됨
        var result = bitData and (1 shl 4) // 0b10100 and 0b10000 > 결과값 0b10000
        println(result.toString(2)) // 10000

        // 우측으로 네 번 밀어주면 원래의 값을 복원 할 수 있음(0b1)
        println(result shr 4) // 1

        // (하위) 다섯 번째 비트에 있는 1을 clear
        bitData = bitData and ((1 shl 4).inv()) // (1 shl 4) > 0b10000
        // 0b10000 > inv() > 0b01111 > bitData 와 and 연산 > 0b10100 and 0b01111
        // 0으로 반전된(하위) 다섯번째비트만 clear 됨
        println(bitData.toString(2)) // 100

        // 10100과 같은지 비트별로 확인을 위해 xor 연산
        println((bitData xor (0b10100)).toString(2)) // 10000
        // (하위) 다섯번째 비트만 다르기 때문에
        // 10000 이 출력 될 것임

        // 비트연산은 앞서 설명 했듯이 아주 제한적인 경우에 사용되지만
        // 반드시 알아야 할 중요한 연산
    }
}